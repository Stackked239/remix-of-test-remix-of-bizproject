/**
 * VISUALIZATION OUTPUT CONTRACT
 *
 * This contract defines the mandatory format for ALL visualization data
 * generated by Phases 1-3. ASCII visualization is architecturally forbidden.
 *
 * Any phase output containing ASCII box-drawing characters will be REJECTED
 * at the validation layer and will not proceed to report generation.
 */

import { z } from 'zod';

// Enumerated visualization types supported by the rendering engine
export const VizTypeEnum = z.enum([
  'gauge',
  'bar_chart',
  'horizontal_bar',
  'comparison_matrix',
  'score_tiles',
  'timeline',
  'risk_matrix',
  'heatmap',
  'radar_chart',
  'priority_table',
  'progress_indicator',
  'trend_sparkline',
  'kpi_card'
]);

// Data point schema with strict typing
export const DataPointSchema = z.object({
  label: z.string().min(1).max(100),
  value: z.number(),
  unit: z.enum(['%', '$', 'count', 'score', 'days', 'ratio', 'none']).optional(),
  category: z.enum([
    'strength',
    'gap',
    'risk',
    'opportunity',
    'neutral',
    'excellence',
    'proficiency',
    'attention',
    'critical'
  ]).optional(),
  secondaryValue: z.number().optional(),
  trend: z.enum(['up', 'down', 'stable']).optional(),
  benchmark: z.number().optional()
});

// Complete visualization specification schema
export const VisualizationSpecSchema = z.object({
  vizId: z.string().uuid().optional(), // Auto-generated if not provided
  vizType: VizTypeEnum,
  title: z.string().min(1).max(200),
  subtitle: z.string().max(300).optional(),
  data: z.array(DataPointSchema).min(1),
  metadata: z.object({
    source: z.string().optional(),
    assessmentSection: z.string().optional(),
    dimensionCode: z.string().optional(),
    chapterCode: z.string().optional(),
    generatedBy: z.enum(['phase1', 'phase2', 'phase3']).optional(),
    confidenceScore: z.number().min(0).max(1).optional()
  }).optional(),
  renderOptions: z.object({
    showLegend: z.boolean().default(true),
    showValues: z.boolean().default(true),
    colorScheme: z.enum(['default', 'monochrome', 'score_bands']).default('default'),
    height: z.enum(['compact', 'standard', 'expanded']).default('standard')
  }).optional()
});

// Type exports
export type VizType = z.infer<typeof VizTypeEnum>;
export type DataPoint = z.infer<typeof DataPointSchema>;
export type VisualizationSpec = z.infer<typeof VisualizationSpecSchema>;

// Collection of visualizations from a single analysis
export const VisualizationCollectionSchema = z.object({
  analysisId: z.string(),
  analysisType: z.string(),
  visualizations: z.array(VisualizationSpecSchema),
  generatedAt: z.string().datetime()
});

export type VisualizationCollection = z.infer<typeof VisualizationCollectionSchema>;

/**
 * ASCII PROHIBITION PATTERN
 * These characters are FORBIDDEN in any pipeline output.
 * Detection of these characters triggers validation failure.
 */
export const FORBIDDEN_ASCII_PATTERN = /[┌┐└┘│─┬┴├┤═║╔╗╚╝╠╣╦╩╬█▓░▲▼►◄●○■□▪▫╭╮╯╰┼]/;

/**
 * Extended ASCII pattern for comprehensive detection
 * Includes all box-drawing, block, and geometric characters
 */
export const FORBIDDEN_ASCII_EXTENDED_PATTERN = /[┌┐└┘│─┬┴├┤═║╔╗╚╝╠╣╦╩╬█▓░▲▼►◄●○■□▪▫╭╮╯╰┼▀▄▌▐▒◆◇◊★☆✓✗✔✘➔➜→←↑↓↔↕]/;

/**
 * Pattern to detect multi-line ASCII art blocks (3+ consecutive lines with forbidden chars)
 */
export const ASCII_BLOCK_PATTERN = /(?:^.*[┌┐└┘│─┬┴├┤═║╔╗╚╝╠╣╦╩╬█▓░▲▼►◄●○■□▪▫╭╮╯╰┼].*$\n?){3,}/gm;

/**
 * Pattern to detect ASCII bar chart patterns (sequences of block characters)
 */
export const ASCII_BAR_PATTERN = /[█▓░]{5,}/g;

/**
 * Validates that content contains NO forbidden ASCII characters
 * @throws Error if ASCII diagram characters are detected
 */
export function assertNoAsciiDiagrams(content: string, context: string): void {
  if (FORBIDDEN_ASCII_PATTERN.test(content)) {
    const match = content.match(FORBIDDEN_ASCII_PATTERN);
    throw new Error(
      `ASCII DIAGRAM VIOLATION in ${context}: ` +
      `Forbidden character "${match?.[0]}" detected. ` +
      `All visualizations must use VisualizationSpec JSON format.`
    );
  }
}

/**
 * Checks if content contains any ASCII diagram characters (non-throwing)
 * @returns true if ASCII diagram characters are found
 */
export function containsAsciiDiagrams(content: string): boolean {
  return FORBIDDEN_ASCII_PATTERN.test(content);
}

/**
 * Counts the number of ASCII diagram character occurrences
 */
export function countAsciiOccurrences(content: string): number {
  const matches = content.match(new RegExp(FORBIDDEN_ASCII_PATTERN.source, 'g'));
  return matches?.length || 0;
}

/**
 * Extract all ASCII diagram blocks from content
 * @returns Array of detected ASCII blocks with their positions
 */
export function extractAsciiBlocks(content: string): Array<{
  content: string;
  startIndex: number;
  endIndex: number;
  lineCount: number;
}> {
  const blocks: Array<{
    content: string;
    startIndex: number;
    endIndex: number;
    lineCount: number;
  }> = [];

  let match: RegExpExecArray | null;
  const blockRegex = new RegExp(ASCII_BLOCK_PATTERN.source, 'gm');

  while ((match = blockRegex.exec(content)) !== null) {
    blocks.push({
      content: match[0],
      startIndex: match.index,
      endIndex: match.index + match[0].length,
      lineCount: match[0].split('\n').length
    });
  }

  return blocks;
}

/**
 * Report interface for ASCII violation detection
 */
export interface AsciiViolationReport {
  hasViolations: boolean;
  totalOccurrences: number;
  blocks: Array<{
    content: string;
    startIndex: number;
    endIndex: number;
    lineCount: number;
  }>;
  singleCharacters: string[];
  context: string;
}

/**
 * Generate a detailed ASCII violation report for a piece of content
 */
export function generateAsciiViolationReport(content: string, context: string): AsciiViolationReport {
  const blocks = extractAsciiBlocks(content);
  const singleMatches = content.match(new RegExp(FORBIDDEN_ASCII_PATTERN.source, 'g')) || [];

  // Filter single characters that are not part of blocks
  const blockChars = new Set(blocks.flatMap(b => b.content.match(new RegExp(FORBIDDEN_ASCII_PATTERN.source, 'g')) || []));
  const singleCharacters = singleMatches.filter(char => !blockChars.has(char));

  return {
    hasViolations: blocks.length > 0 || singleCharacters.length > 0,
    totalOccurrences: singleMatches.length,
    blocks,
    singleCharacters: [...new Set(singleCharacters)],
    context
  };
}
